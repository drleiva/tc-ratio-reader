<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>T/C Ratio Reader (Private)</title>
  <style>
    :root { --card: #fff; --border: #d8d8d8; --shadow: 0 1px 3px rgba(0,0,0,.1); }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin:0; padding:14px;
      background:#f7f7f7;
      color:#111;
    }
    h2{ margin:0 0 10px 0; font-size:20px; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:10px;
      box-shadow:var(--shadow);
      padding:12px;
      width: min(980px, 100%);
    }
    .small{ font-size:13px; color:#444; line-height:1.35; }
    input[type="file"]{ font-size:14px; }
    button, select{
      padding:10px 12px; font-size:15px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
    }
    button.primary{
      background:#111; color:#fff; border-color:#111;
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    canvas{
      width:100%;
      border:1px solid var(--border);
      border-radius:10px;
      touch-action:none;
      background:#fff;
      display:block;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .results{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap:10px;
      margin-top:10px;
    }
    .metric{
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px;
      background:#fff;
    }
    .metric b{ display:block; font-size:13px; color:#444; }
    .metric span{ font-size:20px; font-weight:700; }
    .hint{
      margin-top:10px;
      padding:10px;
      border-radius:10px;
      background:#fff;
      border:1px dashed var(--border);
      color:#333;
      font-size:13px;
      line-height:1.4;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid var(--border);
      border-radius:6px;
      background:#fafafa;
    }
  </style>
</head>

<body>
  <div class="card">
    <h2>T/C Ratio Reader (Private)</h2>
    <div class="row">
      <input type="file" accept="image/*" id="fileInput">
      <button class="primary" id="btnCompute" disabled>Compute</button>
      <button id="btnReset" disabled>Reset ROI</button>
      <button id="btnSwap" disabled>Swap T ↔ C</button>
      <select id="modeSelect" title="Line finding mode" disabled>
        <option value="auto" selected>Auto-detect 2 lines</option>
        <option value="manual">Manual (use ROI only, no peak-find)</option>
      </select>
    </div>
    <div class="small" style="margin-top:8px;">
      Drag the red box over the test window. Use the <b>corner handle</b> to resize.
      Then click <b>Compute</b>.
    </div>
  </div>

  <div class="card grid" style="margin-top:12px;">
    <canvas id="canvas"></canvas>

    <div class="results" id="results" style="display:none;">
      <div class="metric">
        <b>T/C ratio (BG-normalized)</b>
        <span id="mRatio">—</span>
        <div class="small">Computed as (BG−T)/(BG−C)</div>
      </div>
      <div class="metric">
        <b>ΔT (BG − T)</b>
        <span id="mDT">—</span>
        <div class="small">Bigger = darker test line</div>
      </div>
      <div class="metric">
        <b>ΔC (BG − C)</b>
        <span id="mDC">—</span>
        <div class="small">Control contrast reference</div>
      </div>
      <div class="metric">
        <b>RIOD-style (log contrast)</b>
        <span id="mRIOD">—</span>
        <div class="small">log(BG/T) ÷ log(BG/C)</div>
      </div>
    </div>

    <div class="hint" id="output">
      <b>Tips</b><br>
      • If the app mixes up which line is control vs test, click <span class="kbd">Swap T ↔ C</span>.<br>
      • If auto-detection struggles, switch to <span class="kbd">Manual</span> and place ROI tightly around both lines.
    </div>
  </div>

<script>
/**
 * Private, simple strip reader:
 * - Grayscale conversion
 * - BG-normalized contrast (BG - line mean)
 * - Auto: find two line peaks from a vertical darkness profile
 * - Manual: assumes ROI already contains both lines; uses strongest two peaks within ROI
 */

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });

const fileInput = document.getElementById("fileInput");
const btnCompute = document.getElementById("btnCompute");
const btnReset = document.getElementById("btnReset");
const btnSwap = document.getElementById("btnSwap");
const modeSelect = document.getElementById("modeSelect");

const output = document.getElementById("output");
const results = document.getElementById("results");

const mRatio = document.getElementById("mRatio");
const mDT = document.getElementById("mDT");
const mDC = document.getElementById("mDC");
const mRIOD = document.getElementById("mRIOD");

let img = new Image();
let hasImage = false;

// ROI with resize handle (bottom-right)
let roi = { x: 50, y: 50, w: 240, h: 140 };
let dragMode = null; // "move" | "resize" | null
let dragOffset = { x: 0, y: 0 };
let lastComputed = null; // store {tY, cY} for swap

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

fileInput.addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  img = new Image();
  img.onload = () => {
    // Fit canvas to image (pixel-perfect). CSS makes it responsive.
    canvas.width = img.width;
    canvas.height = img.height;
    hasImage = true;

    roi = {
      x: img.width * 0.18,
      y: img.height * 0.35,
      w: img.width * 0.64,
      h: img.height * 0.25
    };

    btnCompute.disabled = false;
    btnReset.disabled = false;
    btnSwap.disabled = true;
    modeSelect.disabled = false;

    results.style.display = "none";
    output.innerHTML = "<b>Loaded.</b> Position the ROI over the test window, then click <b>Compute</b>.";
    draw();
  };

  img.src = URL.createObjectURL(file);
});

btnReset.addEventListener("click", () => {
  if (!hasImage) return;
  roi = {
    x: img.width * 0.18,
    y: img.height * 0.35,
    w: img.width * 0.64,
    h: img.height * 0.25
  };
  lastComputed = null;
  btnSwap.disabled = true;
  results.style.display = "none";
  output.innerHTML = "ROI reset. Reposition and compute again.";
  draw();
});

btnSwap.addEventListener("click", () => {
  if (!lastComputed) return;
  const tmp = lastComputed.tY;
  lastComputed.tY = lastComputed.cY;
  lastComputed.cY = tmp;
  // Recompute metrics quickly using stored peaks.
  computeWithKnownLines(lastComputed.cY, lastComputed.tY);
});

btnCompute.addEventListener("click", () => computeRatio());

function draw() {
  if (!hasImage) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    return;
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0);

  // ROI box
  ctx.save();
  ctx.strokeStyle = "red";
  ctx.lineWidth = Math.max(2, Math.round(Math.min(canvas.width, canvas.height) / 300));
  ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);

  // Resize handle
  const hs = Math.max(10, Math.round(Math.min(canvas.width, canvas.height) / 60));
  ctx.fillStyle = "red";
  ctx.fillRect(roi.x + roi.w - hs, roi.y + roi.h - hs, hs, hs);
  ctx.restore();
}

function canvasToImageCoords(clientX, clientY){
  const r = canvas.getBoundingClientRect();
  // Map CSS pixels -> canvas pixels
  const x = (clientX - r.left) * (canvas.width / r.width);
  const y = (clientY - r.top) * (canvas.height / r.height);
  return { x, y };
}

function isInResizeHandle(x, y){
  const hs = Math.max(10, Math.round(Math.min(canvas.width, canvas.height) / 60));
  const rx = roi.x + roi.w - hs;
  const ry = roi.y + roi.h - hs;
  return x >= rx && x <= rx + hs && y >= ry && y <= ry + hs;
}

function isInROI(x, y){
  return x >= roi.x && x <= roi.x + roi.w && y >= roi.y && y <= roi.y + roi.h;
}

canvas.addEventListener("pointerdown", e => {
  if (!hasImage) return;
  const p = canvasToImageCoords(e.clientX, e.clientY);

  if (isInResizeHandle(p.x, p.y)) {
    dragMode = "resize";
    canvas.setPointerCapture(e.pointerId);
    return;
  }
  if (isInROI(p.x, p.y)) {
    dragMode = "move";
    dragOffset.x = p.x - roi.x;
    dragOffset.y = p.y - roi.y;
    canvas.setPointerCapture(e.pointerId);
  }
});

canvas.addEventListener("pointermove", e => {
  if (!dragMode) return;
  const p = canvasToImageCoords(e.clientX, e.clientY);

  if (dragMode === "move") {
    roi.x = clamp(p.x - dragOffset.x, 0, canvas.width - roi.w);
    roi.y = clamp(p.y - dragOffset.y, 0, canvas.height - roi.h);
  } else if (dragMode === "resize") {
    const minW = Math.max(40, canvas.width * 0.08);
    const minH = Math.max(30, canvas.height * 0.06);
    roi.w = clamp(p.x - roi.x, minW, canvas.width - roi.x);
    roi.h = clamp(p.y - roi.y, minH, canvas.height - roi.y);
  }
  draw();
});

canvas.addEventListener("pointerup", () => dragMode = null);
canvas.addEventListener("pointercancel", () => dragMode = null);

function computeRatio() {
  if (!hasImage) return;

  // Ensure integer ROI for getImageData
  const rx = Math.round(roi.x), ry = Math.round(roi.y);
  const rw = Math.round(roi.w), rh = Math.round(roi.h);
  if (rw < 10 || rh < 10) return;

  const roiData = ctx.getImageData(rx, ry, rw, rh);
  const w = roiData.width;
  const h = roiData.height;
  const d = roiData.data;

  // Grayscale luminance
  const gray = new Float32Array(w * h);
  for (let i=0; i<w*h; i++) {
    const r = d[i*4], g = d[i*4+1], b = d[i*4+2];
    gray[i] = 0.299*r + 0.587*g + 0.114*b;
  }

  // Use central x-band to reduce edge noise
  const x1 = Math.floor(w * 0.18);
  const x2 = Math.floor(w * 0.82);

  // Darkness profile by row: (255 - mean gray)
  const prof = new Float32Array(h);
  for (let y=0; y<h; y++){
    let sum = 0, n = 0;
    for (let x=x1; x<x2; x++){
      sum += gray[y*w + x];
      n++;
    }
    prof[y] = 255 - (sum / n);
  }

  // Smooth profile
  const sm = new Float32Array(h);
  const k = 2; // +/- 2 rows window
  for (let y=0; y<h; y++){
    let s=0, n=0;
    for (let yy=y-k; yy<=y+k; yy++){
      if (yy>=0 && yy<h){ s += prof[yy]; n++; }
    }
    sm[y] = s/n;
  }

  // Peak find
  let peaks = [];
  for (let y=1; y<h-1; y++){
    if (sm[y] > sm[y-1] && sm[y] > sm[y+1]) peaks.push({ y, v: sm[y] });
  }
  peaks.sort((a,b)=>b.v-a.v);

  if (peaks.length < 2) {
    results.style.display = "none";
    output.innerHTML = "Could not detect two line peaks inside ROI. Try resizing ROI tighter, or switch to Manual.";
    return;
  }

  // Choose two peaks that are not too close
  const minSep = Math.max(8, Math.round(h * 0.10));
  let p1 = peaks[0];
  let p2 = null;
  for (let i=1; i<peaks.length; i++){
    if (Math.abs(peaks[i].y - p1.y) >= minSep) { p2 = peaks[i]; break; }
  }
  if (!p2) {
    results.style.display = "none";
    output.innerHTML = "Detected peaks are too close together. Try a taller ROI that includes both lines.";
    return;
  }

  // Convention: Control line is typically "upper" in ROI (smaller y)
  let cY = Math.min(p1.y, p2.y);
  let tY = Math.max(p1.y, p2.y);

  // Store for swap button
  lastComputed = { cY, tY, gray, w, h, x1, x2 };
  btnSwap.disabled = false;

  computeWithKnownLines(cY, tY);
}

function computeWithKnownLines(cY, tY){
  const { gray, w, h, x1, x2 } = lastComputed;

  // Background estimate: top 15% + bottom 15%
  function meanBand(yStart, yEnd){
    let sum=0, n=0;
    for (let y=yStart; y<=yEnd; y++){
      for (let x=x1; x<x2; x++){
        sum += gray[y*w + x]; n++;
      }
    }
    return sum / n;
  }
  const topEnd = Math.max(0, Math.floor(h*0.15)-1);
  const botStart = Math.min(h-1, Math.floor(h*0.85));
  const BG = (meanBand(0, topEnd) + meanBand(botStart, h-1)) / 2;

  // Line mean over a small vertical band around the line center
  function lineMean(yc){
    const half = Math.max(2, Math.round(h * 0.03)); // ~3% of ROI height
    const ys = clamp(yc - half, 0, h-1);
    const ye = clamp(yc + half, 0, h-1);
    return meanBand(ys, ye);
  }
  const C = lineMean(cY);
  const T = lineMean(tY);

  // BG-normalized contrasts
  const dT = Math.max(0, BG - T);
  const dC = Math.max(0, BG - C);

  // Avoid divide-by-zero
  const ratio = (dC > 1e-6) ? (dT / dC) : 0;

  // RIOD-style log contrast (simple + stable)
  // Note: add epsilon to prevent log(0) issues
  const eps = 1e-3;
  const riod = (Math.log((BG + eps) / (T + eps))) / (Math.log((BG + eps) / (C + eps)));

  // Show
  results.style.display = "grid";
  mRatio.textContent = ratio.toFixed(2);
  mDT.textContent = dT.toFixed(1);
  mDC.textContent = dC.toFixed(1);
  mRIOD.textContent = isFinite(riod) ? riod.toFixed(2) : "—";

  output.innerHTML =
    `<b>Done.</b> Computed from grayscale intensity inside ROI.<br>` +
    `<span class="small">If T/C seems inverted, click <span class="kbd">Swap T ↔ C</span>.</span>`;
}
</script>
</body>
</html>
